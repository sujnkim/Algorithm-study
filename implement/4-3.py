"""
[ch4.구현] 4-3: 왕실의 나이트 | 난이도1 | 실전문제
INPUT: 현재 나이트가 위치한 곳의 좌표를 나타내는 두 문자로 구성된 문자열
    * ex) a1처럼 열, 행으로 이루어진다
OUTPUT: 나이트가 이동할 수 있는 경우의 수
"""
import time

# input
loc = input()

"""
[풀이 구상]---------------------------------------------------------
나이트 이동 규칙: L자 형태로 이동 가능(단, 8x8 평면 밖으로는 나갈 수 없음)
1) 수평으로 2, 수직으로 1칸
2) 수직으로 2, 수평으로 1칸

주어진 칸을 기준으로 2칸, 1칸씩 움직임
2칸 움직이는 방법은 상하좌우 4가지, 1칸 움직이는 방법은 상하or좌우 2가지씩 존재
따라서 전부 확인 할 칸의 개수는 4*2 = 8개
"""

# solve-------------------------------------------------------------
start = time.time()
result = 0

# 입력은 '열행' 한 문자열으로 들어옴(순서에 주의)
# 입력받은 문자를 int형으로 바꿔야 계산 가능
# ord(): 문자 -> 유니코드 정수
c = ord(loc[0])-ord('a') +1
r = int(loc[1])

# 가능한 방법 8가지(수평이동,수직이동)를 저장
dloc = [(2,1),(2,-1),(-2,1),(-2,-1),(1,2),(1,-2),(-1,2),(-1,-2)]

# 8가지 이동경로
for d in dloc:
    newr = r + d[0]
    newc = c + d[1]

    # 8x8 범위를 벗어나는지 확인
    if newr<1 or newc<1 or newr>8 or newc>8:
        continue    
    result += 1

#output
print(result)

end = time.time()
print(f"{end-start:.5f} sec")

"""
[느낀점]--------------------------------------------------------------
+ 입력이 '행열'이 아니라 '열행'의 형태로 들어오기 때문에 순서에 주의할 것.
-> 처음에 코드를 짤 때 헷갈려서 잘못 입력 받았음...

+ ord()를 사용하면 문자를 유니코드 정수로 변환할 수 있음
-> ord('a')는 0이나 1이 아니라 97
-> 따라서 이 문제의 경우, -ord('a')+1 계산을 통해 a=1이 되도록 해 줌

+ 처음에 생각했던 코드는... LRUD 4가지 이동법을 리스트로 저장했었음
-> 2칸 이동, 범위 확인
-> 만약 범위 내라면 1칸 이동, 범위 확인
-> 범위 내라면, result를 1 증가
이런 식이라서 range(4)크기의 반복문 내에 if문과 range(2)반복이 있는 방식이었는데
좌표 계산이 조금 복잡하기도 하고 예쁘지 않아서...
한 개의 dloc리스트 내에 이동 가능한 좌표 변화량을 전부 저장해서
반복문을 한 개로 만들었음

+ 어떤 위치에서 다른 위치로 이동하는 시뮬레이션 문제에서는,
얼만큼 이동하는 지 그 변화량을 리스트에 담아두고
반복문을 활용하여 확인하는 형식으로 풀면 될 듯?
->4-1 상하좌우에서는 dx, dy라는 두 리스트를 선언하여 x,y 각 좌표의 변화량을 따로 저장.
->이번 4-3 나이트문제에서는 가능한 이동 경로 8가지를 리스트 내의 튜플 형식으로 저장.
"""